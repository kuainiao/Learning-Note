## 主从结构
每一个节点上都包含全量的数据，写操作需要在所有的节点上都执行一遍，从而保证数据的一致性，最常用的方法是**主从结构**:
1. 一个数据副本被定义为主节点，如果客户端想要写数据，必须将写操作发送给主节点，主节点首先将数据写到自己的存储上。
2. 其他的节点就是从节点。当主节点写入新的数据时，它会将数据更改以replication log 或者 change stream 的方式发送给从节点，每一个从节点按照**主节点写入数据的顺序写入新的数据**。
3. 当客户端想要**读取数据时，它可以请求主节点或者从节点，但是对于写请求来说，只能由主节点处理**。

![](images/5-1.jpg)

很多关系型数据库都支持这种模型，比如PostgreSQL, MySQL, Oracle Data Guard 和 SQL Server ， 它同样用在了一些非关系型数据库，比如 MongoDB, RethinkDB 和 Espresso 。最后，不仅是数据库系统使用主从结构，分布式消息队列比如Kafka和RabbitMQ都使用它


### 同步复制 VS 异步复制
多副本系统中很重要的一个细节就是 **数据是同步更新还是异步更新**

![](images/5-2.jpg)

在5-2中，主节点等待Follower1更新完成才发送回复(同步)，不等待Follower2的回应(异步)。  
同步的优点：从节点数据总是最新的，如果主节点挂了，从节点上仍有最新的数据。  
同步的缺点：如果没有收到从节点的回应(从节点挂了 or 网络问题 or 其他)，主节点会阻塞所有的写操作等待。  
**在实践中，是不会让全部从节点都处于同步状态，当我们打开数据库同步更新，它通常意味着一个从节点是同步的，其他从节点仍然是异步的**。如果同步从节点不可用了，会有一个异步从节点变为同步状态，从而保证整个系统中至少有两个节点有最新的数据。这种称为**半同步**  
通常，如果一个主从结构被设置为完全异步的，当主节点失败并且无法恢复，任何还没有被从节点复制的写操作都会丢失，即使主节点给客户端返回了确认也不代表写操作是可靠的。它的一个优点在于即使所有的从节点都挂了也不影响主节点继续处理。  
虽然完全异步的可靠性很弱，但仍得到了广泛的应用，特别是在从节点很多或者地理分散的情况下，我们将在 "Problems with Replication Lag" 中继续讨论这个问题。  

### 副本的一些研究
在异步结构中如果主节点挂了会导致丢失数据，因此研究者提出了一些防止丢失数据并且提供高性能的方法，例如 chain replication 是一个同步复制的变种，被用在了 Microsoft Azure Storage  
在副本 一致性(consistency) 和 共识(多个节点对数据达成一致) 之间有很强的关联性，这些细节将会在第9章讨论。

### 设置新的从节点
随着时间的推移，系统需要设置新的从节点(横向扩展 or 替换挂掉的从节点)，如何确保新的从节点有主节点的全量数据？
1. 在某个时间点获取主节点的一个快照，大部分数据库都带有这个功能。
2. 将快照拷贝到新的从节点。
3. 从节点连接到主节点请求快照创建之后的数据。这需要快照关联到主节点日志上一个确定的位置。这个位置在PostgreSQL中称为 log sequence number ，在 MySQL中称为 binlog coordinates
4. 从节点处理完增量数据之后就可以正常的接收主节点发来的数据了

### 处理节点失败
目标：个别节点的失败不会导致整个系统的崩溃
#### 从节点失败
从节点失败重启后可以通过自己节点上面的日志，从主节点请求增量数据，从而恢复数据一致性。
#### 主节点失败
主节点失败的情况下，一个从节点会被提升为主节点，客户端需要重新配置将写请求发送给新的主节点，其他的从节点需要从新的主节点接收数据。这个过程称为 **failover (失败自动切换)**  
自动化的失败切换包含如下步骤：
1. 判断主节点已经失败。失败可能有很多原因，比如断点，系统崩溃，网络问题等等，并没有一个万全之策判断具体的错误，大部分系统使用**超时**来判断，节点之间通常会相互之间发送消息，如果一个节点在一段时间内没有回复，就被认为失败。
2. 选择新的主节点。 通常有一个专门的**选择过程(新的主节点由绝大部分从节点选出)，或者有一个专门的协调者指定新的主节点**。 **最适合**的候选者通常是数据最新的那个从节点。第九章将讨论多个节点达成共识的问题
3. 重新设置系统适应新的主节点。客户端需要将写请求发送到新的主节点；老的主节点恢复之后需要变为从节点。

上述步骤面临的问题：
1. 异步模式下，**旧的主节点在新的主节点还没有收到写请求时就失败了，当新的主节点产生之后，旧的主节点恢复变为从节点，这些丢失写请求如何处理？**一个常用的方法是直接丢弃它们，这可能会影响整体可用性。
2. 如果其他的数据系统依赖于数据库，那么丢弃数据是相当危险的。例如GitHub的一次事故，一个没有最新数据的MySQL从节点被提升为主节点，数据库使用自增的计数器来为新记录分配主键，由于新的主节点计数器远远落后于旧的主节点，它重用了一些之前已经被旧主分配的主键。这些主键还被用在了Redis中，这导致了Redis和MySQL之间数据的不一致，导致一些私有数据被发送给了错误的用户。
3. **脑裂问题**，当两个节点都认为自己是主节点，都接收写请求，并且没有处理冲突的进程，整个系统可能会崩溃。某些系统检测到两个主节点之后，会直接关闭其中一个，然而如果不仔细设计检测流程，可能会导致两个主节点都被关闭。
4. **超时设置的困境**，检测主节点失败的超时设置，时间太短容易误报，时间太长导致反应太慢，系统可能不可用。

**节点失败，网络问题，还有副本一致性，容错，可用性以及延时方面的各种取舍是分布式系统面临的基本问题**。


### 实现副本日志